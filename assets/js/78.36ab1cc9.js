(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{444:function(t,a,s){"use strict";s.r(a);var e=s(45),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue-和-react"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react"}},[t._v("#")]),t._v(" Vue 和 React")]),t._v(" "),s("h2",{attrs:{id:"前端框架的分类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端框架的分类"}},[t._v("#")]),t._v(" 前端框架的分类")]),t._v(" "),s("p",[t._v("下面的公式几乎可以概括所有现代前端框架的实现原理：")]),t._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UI")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("其中：")]),t._v(" "),s("ul",[s("li",[t._v("state 代表“当前视图状态”；")]),t._v(" "),s("li",[t._v("f 代表“框架内部运行环境”；")]),t._v(" "),s("li",[t._v("UI 代表“宿主环境的视图”。")])]),t._v(" "),s("p",[t._v("描述 UI 主要分为模版语法以及 JSX 的方式，React 认为“UI 本质上与逻辑存在耦合的部分”，使用了 JSX 的方式，在 UI 上直接绑定事件，在状态变化后改变 UI 的样式与结构。Vue 则采用了模版语法。模版语法的出发点是，既然前端框架使用 HTML 描述 UI，那就扩展 HTML 的语法，来描述逻辑，即“从 UI 出发，扩展 UI，描述逻辑”。JSX 的出发点是，既然前端框架使用 ES 描述逻辑，就扩展 ES 语法，使它能够描述 UI，即“从逻辑出发，扩展逻辑，描述 UI”。")]),t._v(" "),s("p",[t._v("在上述公式中，state 本质是自变量，自变量通过直接或间接的方式改变 UI（此处 UI 仅仅是对实际宿主环境 UI 的描述），两者之间的描述可以抽象为：")]),t._v(" "),s("ul",[s("li",[t._v("自变量与 UI 的对应关系（元素 -> UI）")]),t._v(" "),s("li",[t._v("自变量与组件的对应关系（元素 -> 组件 -> UI）")]),t._v(" "),s("li",[t._v("自变量与应用的关系（元素 -> 组件 -> 应用 -> UI）")])]),t._v(" "),s("p",[t._v("这三种抽象分别对应了三类前端框架：")]),t._v(" "),s("ul",[s("li",[t._v("元素级框架（Svelte、Solid.js）")]),t._v(" "),s("li",[t._v("组件级框架（Vue）")]),t._v(" "),s("li",[t._v("应用级框架（React）")])]),t._v(" "),s("h2",{attrs:{id:"前端框架使用的技术"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端框架使用的技术"}},[t._v("#")]),t._v(" 前端框架使用的技术")]),t._v(" "),s("h3",{attrs:{id:"细粒度更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#细粒度更新"}},[t._v("#")]),t._v(" 细粒度更新")]),t._v(" "),s("p",[t._v("在 React 中，定义因变量时需要显式指明“因变量依赖的自变量”，比如：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// React")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useMemo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("而 Vue、Mobx 中并不需要显式指明，它们使用的“能自动追踪依赖的技术”被称为“细粒度更新”：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Vue")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("computed")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Mobx")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("computed")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("data "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("细粒度更新有两个显著优点：")]),t._v(" "),s("ul",[s("li",[t._v("无需显式指明依赖")]),t._v(" "),s("li",[t._v("可以自动追踪依赖")])]),t._v(" "),s("p",[t._v("虽然 React 也可以实现细粒度更新，但是 React 属于应用级框架，其更新的细粒度不需要很细。作为代价，React Hooks 在使用上会受到与上述两个优点对应的两种限制。")]),t._v(" "),s("h3",{attrs:{id:"aot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aot"}},[t._v("#")]),t._v(" AOT")]),t._v(" "),s("p",[t._v("现代前端框架都需要“编译这一步骤”，用于：")]),t._v(" "),s("ul",[s("li",[t._v("将 UI 转换为宿主环境可识别的代码；")]),t._v(" "),s("li",[t._v("代码转化，比如 ts 到 js，实现 polyfill 等；")]),t._v(" "),s("li",[t._v("执行一些编译时优化；")]),t._v(" "),s("li",[t._v("代码打包、压缩、混淆。")])]),t._v(" "),s("p",[t._v("编译可以选择两个时机执行：")]),t._v(" "),s("ul",[s("li",[t._v("代码在构建时，称为 AOT（Ahead Of Time，提前编译或预编译），宿主环境获得的是编译后的代码；")]),t._v(" "),s("li",[t._v("代码在宿主环境执行时，称为 JIT（Just In Time，即时编译），代码在宿主环境中编译并执行。")])]),t._v(" "),s("p",[t._v("借助 AOT 可以对模版语法编译时进行优化，从而减少根据自变量变化计算出 UI 变化的开销，因为模版语法是固定的，固定意味着可分析，可分析意味着在编译时可以标记模版语法的静态部分和动态部分，从而在寻找“变化的 UI”时可以跳过静态部分。")]),t._v(" "),s("p",[t._v("“采用 JSX 描述 UI”的前端框架则很难从 AOT 中受益，因为 JSX 是 ES 的语法糖，ES 语句的灵活性使其很难进行静态分析。有两个思路可以实现“采用 JSX 描述 UI”的前端框架在 AOT 中受益：")]),t._v(" "),s("ul",[s("li",[t._v("使用新的 AOT 实现")]),t._v(" "),s("li",[t._v("约束 JSX 的灵活性")])]),t._v(" "),s("h3",{attrs:{id:"virtual-dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[t._v("#")]),t._v(" Virtual DOM")]),t._v(" "),s("p",[t._v("所谓虚拟 DOM，其工作原理主要是：")]),t._v(" "),s("ul",[s("li",[t._v("将“元素描述的 UI”转化为“VDOM 描述的 UI”")]),t._v(" "),s("li",[t._v("对比变化前后“VDOM 描述的 UI”，计算出 UI 中发生变化的部分。")])]),t._v(" "),s("p",[t._v("Vue 使用模版语法描述 UI，编译为 render 函数；React 使用 JSX 描述 UI，编译为 createElement 方法。")]),t._v(" "),s("p",[t._v("VDOM 有以下三个优点：")]),t._v(" "),s("ul",[s("li",[t._v("相对于真实 DOM，体积更小。DOM 包含了非常多的属性和方法。")]),t._v(" "),s("li",[t._v("相较于 AOT 更强大的描述能力。")]),t._v(" "),s("li",[t._v("多平台渲染的抽象能力。")])]),t._v(" "),s("h2",{attrs:{id:"前端框架的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端框架的实现原理"}},[t._v("#")]),t._v(" 前端框架的实现原理")]),t._v(" "),s("p",[t._v("从编译时还是运行时上看：")]),t._v(" "),s("ul",[s("li",[t._v("Svelte 是极致的编译时框架")]),t._v(" "),s("li",[t._v("React 是极致的运行时框架")]),t._v(" "),s("li",[t._v("Vue 3 同时拥有两者的特性（AOT 和 VDOM），比较均衡。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);