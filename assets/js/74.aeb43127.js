(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{440:function(t,e,a){"use strict";a.r(e);var v=a(45),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-虚拟-dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-虚拟-dom"}},[t._v("#")]),t._v(" React 虚拟 DOM")]),t._v(" "),a("p",[t._v("当每次 state 或者  props 改变的时候，React 都会执行 render()。")]),t._v(" "),a("p",[t._v("当有以下情况：")]),t._v(" "),a("p",[a("strong",[t._v("情况一")]),t._v("：")]),t._v(" "),a("ol",[a("li",[t._v("拿到 state 数据")]),t._v(" "),a("li",[t._v("JSX 模版")]),t._v(" "),a("li",[t._v("数据＋模版结合，生成真实的DOM，显示")]),t._v(" "),a("li",[t._v("state 发生改变")]),t._v(" "),a("li",[t._v("数据+模版结合，生成真实的DOM，替换原始的 DOM")])]),t._v(" "),a("p",[t._v("这是最笨的一种方式来实现 DOM 的更新，它有以下缺陷：")]),t._v(" "),a("ul",[a("li",[t._v("第一次生成了一个完整的DOM片段，消耗性能")]),t._v(" "),a("li",[t._v("第二次生成了一个完整的DOM片段，消耗性能")]),t._v(" "),a("li",[t._v("第二次的 DOM 替换第一次的 DOM，非常耗性能")])]),t._v(" "),a("p",[t._v("针对情况一的问题，试想"),a("strong",[t._v("情况二")]),t._v("：")]),t._v(" "),a("ol",[a("li",[t._v("拿到 state 数据")]),t._v(" "),a("li",[t._v("JSX 模版")]),t._v(" "),a("li",[t._v("数据＋模版结合，生成真实的 DOM，显示")]),t._v(" "),a("li",[t._v("state 发生改变")]),t._v(" "),a("li",[t._v("数据＋模版结合，生成真实的 DOM，并不直接替换原始的 DOM")]),t._v(" "),a("li",[t._v("新的 DOM(DocumentFragment) 和原始的 DOM 做比对,找差异")]),t._v(" "),a("li",[t._v("找出某个标签/元素发生了变化")]),t._v(" "),a("li",[t._v("只用新的 DOM 中的该元素，替换掉老的 DOM 中的该元素")])]),t._v(" "),a("p",[t._v("用先对比的方式替换原来全部替换的方式，这样做会有一定的性能提升，但是也有一定的缺陷：")]),t._v(" "),a("ul",[a("li",[t._v("对比算法也需要性能，性能提升并不明显")])]),t._v(" "),a("p",[a("strong",[t._v("情况三：React的做法")])]),t._v(" "),a("ol",[a("li",[t._v("state 数据")]),t._v(" "),a("li",[t._v("JSX 模版")]),t._v(" "),a("li",[t._v("生成虚拟DOM（虚拟 DOM 就是一个JS对象，用它来描述真实 DOM)，这一步有一定的性能损耗，但是不高(JS -> JS < JS -> DOM)")]),t._v(" "),a("li",[t._v("数据+模版结合,生成真实的 DOM，来显示")]),t._v(" "),a("li",[t._v("state 发生变化")]),t._v(" "),a("li",[t._v("生成新的虚拟 DOM（相对于原来生成新的 DOM，极大提升性能）")]),t._v(" "),a("li",[t._v("比较原始虚拟 DOM 和新的虚拟 DOM 的区别（两个 JS 对象的比对比原来 DOM 结点的比对性能消耗更小，极大提升性能）")]),t._v(" "),a("li",[t._v("直接操作 DOM，改变区别中的内容")])]),t._v(" "),a("p",[t._v("总结，在一些情况下，使用虚拟 DOM 可能会更消耗性能，但是在大部分情况下，它能极大的提高性能。")]),t._v(" "),a("h2",{attrs:{id:"react-createelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-createelement"}},[t._v("#")]),t._v(" React.createElement")]),t._v(" "),a("p",[t._v("JSX 模板里的并不是真实的 DOM，实际上会先通过 React.createElement 转换成虚拟 DOM (JS 对象)，然后再转换成真实的 DOM。")]),t._v(" "),a("h2",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),a("ol",[a("li",[t._v("首先性能在大部分情况下会提升。")]),t._v(" "),a("li",[t._v("虚拟 DOM 使跨端应用得以实现，React Native 便是一个体现。这是因为，原来的情况下 DOM 并不能在移动端被渲染，但是虚拟 DOM 可以被移动端识别，生成移动端能够渲染的组件。")])]),t._v(" "),a("h2",{attrs:{id:"diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" Diff 算法")]),t._v(" "),a("p",[t._v("主要用在原始虚拟 DOM 和新的虚拟 DOM 的比对。")]),t._v(" "),a("p",[t._v("首先思考 state 的改变。归根到底，重新渲染只会发生在 state 发生改变的情况下（props 即父组件的 state），也就是使用了 setState 函数。如果在短时间内，连续几次改变 state，React 可能会做好几次虚拟 DOM 的比对，这样非常耗费性能。于是 "),a("strong",[t._v("setState 函数被设计成异步")]),t._v("，React 可以把多次 setState 合并成一个，然后只做一次虚拟 DOM 的比对，这样就可以节省很多性能。")]),t._v(" "),a("p",[t._v("Diff 算法会进行同层的 DOM 比对，一旦上层 DOM 结点不匹配，就会把底下所有结点删除，这可能会造成一些性能的浪费（比如父结点改变，但子结点都一样），但是同层比对的速度会非常的快，减少了比对的时间性能消耗。")]),t._v(" "),a("p",[t._v("在循环中 key 值的加入同时也有利于 Diff 算法的比对，通过两个相同的 key 值对应结点的对比，很快就可以得出比对结果。同时这也是为什么 key 值不要是 index 的原因，因为一旦删除某个列表结点，后面的 key 值和结点将会发生错位：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" a\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" b\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" c\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 删除2结点")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" a\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" c\n")])])]),a("p",[t._v("这样会让 Diff 算法误以为结点发生改变从而重新渲染。")])])}),[],!1,null,null,null);e.default=_.exports}}]);