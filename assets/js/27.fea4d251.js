(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{397:function(v,_,t){"use strict";t.r(_);var e=t(45),o=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"重排-reflow-和重绘-repaint"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重排-reflow-和重绘-repaint"}},[v._v("#")]),v._v(" 重排（Reflow）和重绘（Repaint）")]),v._v(" "),t("h2",{attrs:{id:"重排的触发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重排的触发"}},[v._v("#")]),v._v(" 重排的触发")]),v._v(" "),t("p",[v._v("重排也称为回流，当通过 JS 或 CSS 修改 DOM 元素的几何属性（比如长度、宽度）时，会触发完整的渲染流水线，这就是重排。")]),v._v(" "),t("p",[v._v("重排的触发一般有以下几种情况：")]),v._v(" "),t("ul",[t("li",[v._v("页面一开始渲染的时候（这避免不了）")]),v._v(" "),t("li",[v._v("添加或删除可见的DOM元素")]),v._v(" "),t("li",[v._v("元素的位置发生变化")]),v._v(" "),t("li",[v._v("元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）")]),v._v(" "),t("li",[v._v("内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代")]),v._v(" "),t("li",[v._v("浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）")])]),v._v(" "),t("p",[v._v("还有一些容易被忽略的操作：比如获取一些特定属性的值")]),v._v(" "),t("blockquote",[t("p",[v._v("offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight")])]),v._v(" "),t("p",[v._v("这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流")]),v._v(" "),t("p",[v._v("除此还包括"),t("code",[v._v("getComputedStyle")]),v._v("方法，原理是一样的")]),v._v(" "),t("h2",{attrs:{id:"重绘的触发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘的触发"}},[v._v("#")]),v._v(" 重绘的触发")]),v._v(" "),t("p",[v._v("当修改的属性不涉及几何属性（比如字体颜色）时，会省略流水线中的 Layout、Layer 过程，这种情况称为重绘。触发重排一定会触发重绘。除此之外，还有以下几种情况：")]),v._v(" "),t("ul",[t("li",[v._v("颜色的修改")]),v._v(" "),t("li",[v._v("文本方向的修改")]),v._v(" "),t("li",[v._v("阴影的修改")])]),v._v(" "),t("h2",{attrs:{id:"如何减少或避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何减少或避免"}},[v._v("#")]),v._v(" 如何减少或避免")]),v._v(" "),t("p",[v._v("避免重排：")]),v._v(" "),t("ul",[t("li",[v._v("如果想设定元素的样式，通过改变元素的"),t("code",[v._v("class")]),v._v("类名（尽可能在 DOM 树的最里层）")]),v._v(" "),t("li",[v._v("避免设置多项内联样式")]),v._v(" "),t("li",[v._v("应用元素的动画，使用"),t("code",[v._v("position")]),v._v("属性的"),t("code",[v._v("fixed")]),v._v("值或"),t("code",[v._v("absolute")]),v._v("值")]),v._v(" "),t("li",[v._v("避免使用"),t("code",[v._v("table")]),v._v("布局，"),t("code",[v._v("table")]),v._v("中每个元素的大小以及内容的改动，都会导致整个"),t("code",[v._v("table")]),v._v("的重新计算")]),v._v(" "),t("li",[v._v("对于那些复杂的动画，对其设置"),t("code",[v._v("position: fixed/absolute")]),v._v("，尽可能地使元素脱离文档流，从而减少对其他元素的影响")]),v._v(" "),t("li",[v._v("使用 CSS3 硬件加速，可以让"),t("code",[v._v("transform")]),v._v("、"),t("code",[v._v("opacity")]),v._v("、"),t("code",[v._v("filters")]),v._v("这些动画不会引起重排和重绘")]),v._v(" "),t("li",[v._v("避免使用 CSS 的 "),t("code",[v._v("JavaScript")]),v._v("表达式")]),v._v(" "),t("li",[v._v("在使用"),t("code",[v._v("JavaScript")]),v._v("动态插入多个节点时, 可以使用"),t("code",[v._v("DocumentFragment")]),v._v("，创建后一次插入，就能避免多次的渲染性能")])]),v._v(" "),t("blockquote",[t("p",[v._v("当修改“不涉及重排、重绘的属性”（比如 transform 属性）时，会省略流水线中的 Layout、Layer、Paint 过程，仅执行合成线程的绘制工作，这种情况称为合成。这也是 CSS 动画性能优于 JS 动画性能的原因。前者可能仅涉及合成，而后者会涉及重排、重绘。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);