(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{409:function(t,a,s){"use strict";s.r(a);var n=s(45),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"执行上下文与作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文与作用域"}},[t._v("#")]),t._v(" 执行上下文与作用域")]),t._v(" "),s("h2",{attrs:{id:"执行上下文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),s("p",[t._v("执行上下文的概念在 JavaScript 中非常重要，变量或函数的上下文决定了他们可以访问哪些数据，以及它们的行为。每一个执行上下文都有与之关联的"),s("strong",[t._v("变量对象")]),t._v("，在函数中它叫做"),s("strong",[t._v("活动对象")]),t._v("，只在函数执行期间存在。可以把它理解为存放变量的对象，在每个执行上下文中，所有的变量和函数都存在于这个对象上。")]),t._v(" "),s("blockquote",[s("p",[t._v("注意：未经声明便初始化的变量将被添加到全局上下文的变量对象中。")])]),t._v(" "),s("p",[t._v("全局上下文是最外层的上下文，即 window。根据宿主环境的不同，全局上下文的变量对象可能不一样。执行上下文一般分为三类，全局上下文、函数上下文以及 eval()。上下文在其内部代码执行完毕后会被销毁，包括其中的变量和函数。每个程序都会有多个上下文，JavaScript 引擎以栈的方式来处理它们，其中栈的最底部是全局上下文。")]),t._v(" "),s("p",[t._v("每个函数都有自己的上下文，当代码执行到该函数调用时，对应的函数上下文便进入上下文栈，在函数执行完毕后，上下文栈便将之弹出，控制权交给新的栈顶上下文。比如以下代码：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" color "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeColor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" anotherColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'red'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapColors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" tempColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" anotherColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    anotherColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" color"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    color "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tempColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapColors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeColor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("当程序执行到 "),s("code",[t._v("changeColor();")]),t._v(" 时，changeColor 函数的上下文入栈，遇到 "),s("code",[t._v("swapColors();")]),t._v(" 时，swapColors 函数的上下文入栈，直到其中的代码执行完毕，这两个上下文环境依次从栈顶弹出，控制权回到全局上下文手中。")]),t._v(" "),s("h2",{attrs:{id:"变量声明与作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量声明与作用域"}},[t._v("#")]),t._v(" 变量声明与作用域")]),t._v(" "),s("p",[t._v("ES6 之前，只能通过 var 声明变量，ES6 之后，加入了 let 和 const 声明。")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("使用 var 的函数作用域声明")]),t._v("\n在使用 var 声明变量是，变量会被自动添加到最接近的上下文中。在函数中，最接近的上下文是函数的局部上下文。这也就是为什么在函数中声明的变量外部访问不到的原因。\nvar 声明的变量会被拿到函数或全局作用域的顶部，这个过程叫变量提升：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// undefined")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("使用 let 的块级作用域声明")]),t._v("\n块级作用域由最近的一对'{}'界定。 除了作用域的不同，let 在同一作用域中不能声明两次，var 的话会忽略前面的声明。严格的说，let 声明的变量也会被提升，但是由于“暂时性死区”，在初始化之前不能使用 let 变量：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ReferenceError: Cannot access 'b' before initialization")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("使用 const 的常量声明")]),t._v("\n使用 const 声明的变量必须同时初始化为某个值，一经声明在其生命周期的任何时候不可以再重新赋值。对于 const 声明的对象，其引用不可以再修改，但是对象的属性和属性值可以被改变。除了这些，const 和 let 在其他方面是一致的。")])])]),t._v(" "),s("blockquote",[s("p",[t._v("Ps：由于 const 声明变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不是通过查询表进行变量查询，谷歌的 V8 执行的也是这种优化。所以说，在开发过程中，除非确定变量在未来一定会发生改变，否则尽量都使用 const 来声明，这样既可以提前发现重新赋值导致的 bug，也可以提升一点性能。")])]),t._v(" "),s("p",[t._v("在特定的上下文读取或写入而引用标识符时，必须通过搜索查找该标识符以确定它表示什么。搜索过程沿着作用域链进行（对于上下文中的变量，如果是对象的话，还会对它的"),s("strong",[t._v("原型链")]),t._v("进行深度查找），如果找到则搜索停止，变量确定；如果找不到则沿着作用域链继续网上找，知道搜索完全局上下文的变量对象，仍未找到说明未声明。")]),t._v(" "),s("blockquote",[s("p",[t._v("Ps：访问局部变量比访问全局变量快的多，因为不用切换作用域。")])]),t._v(" "),s("h2",{attrs:{id:"作用域链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),s("p",[t._v("上下文中的代码在执行过程中，会创建一条由变量对象组成的作用域链，代码正在执行的上下文对应的变量对象处于作用域链的最前端，然后依次是上一层上下文中的变量对象，再上一层的变量对象...直到全局上下文中的变量对象。")]),t._v(" "),s("blockquote",[s("p",[t._v("Ps：通过 var 声明的全局变量和函数都会成为全局上下文中的属性和方法，而 let 和 const 的顶级声明不会定义在全局上下文中，但是在作用域链解析的效果上是一样的。")])]),t._v(" "),s("p",[t._v("还是刚才那个例子：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" color "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'blue'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeColor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" anotherColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'red'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapColors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" tempColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" anotherColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    anotherColor "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" color"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    color "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tempColor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以访问到 color、anotherColor 和 tempColor")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swapColors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 可以访问到 color、anotherColor，不能访问到 tempColor  ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 只能访问到 color")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeColor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("这是因为作用域链是往外连接的，内部上下文可以通过作用域链访问到外部上下文的一切，而外部的上下文无法访问到内部上下文的任何东西。")]),t._v(" "),s("p",[t._v("作用域链可以通过 try/catch 语句的 catch块或者 with 增强。对于 with 来说，会向作用域链前端添加指定的对象；对于catch 语句来说，则会创建一个新的变量对象，这个变量对象包含要抛出的错误对象的声明。这两种增强，都是向作用域链的最前端添加对象。")]),t._v(" "),s("h2",{attrs:{id:"引申-global-与-window"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#引申-global-与-window"}},[t._v("#")]),t._v(" 引申：Global 与 window")]),t._v(" "),s("p",[t._v("在 JavaScript 中，其实是不存在全局变量或全局函数这种东西，所有全局作用域中定义的变量和函数都会变成 Global 对象的属性，包括一些全局使用的方法甚至引用类型的构造函数，都是 Global 的方法与属性。而 window，是 Global 在浏览器中充当类似代理的角色。")]),t._v(" "),s("blockquote",[s("p",[t._v("Ps：除此之外，在全局作用域中，还有一个 Math 对象，它包含完成复杂计算的属性和方法。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);